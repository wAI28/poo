<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>탕탕특공대 샷건 v.12.6</title>
<style>
  body { margin:0; overflow:hidden; background:#222; }
  canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const VERSION = "v.12.6";

const map = { width: canvas.width*5, height: canvas.height*5 };
const player = { x: map.width/2, y: map.height/2, radius:20, color:"white", speed:5, hp:100, maxHp:100, xp:0, level:1 };

let bullets = [];
let lastShot = 0;
let reloading = false;
let reloadTime = 1000;
let lastReload = 0;
let ammo = 2;

const joystick = { radius: 80, x:150, y:canvas.height-150, stickX:150, stickY:canvas.height-150, active:false, vx:0, vy:0, touchId:null };

const grass = [];
for(let i=0;i<1200;i++){
  grass.push({ x: Math.random()*map.width, y: Math.random()*map.height, size:3 + Math.random()*4, color: Math.random()>0.5 ? "#7cfc00" : "#adff2f" });
}

let mapOffset = {x: canvas.width/2 - player.x, y: canvas.height/2 - player.y};

let enemies = [];
const spawnInterval = 1000; // 스폰율 ↑
let lastSpawn = 0;

let xpList = [];

canvas.addEventListener("touchstart", e => {
  for(let t of e.changedTouches){
    const dx = t.clientX - joystick.x;
    const dy = t.clientY - joystick.y;
    if(Math.hypot(dx, dy)<=joystick.radius && joystick.touchId===null){ 
      joystick.active = true;
      joystick.touchId = t.identifier;
      joystick.stickX = t.clientX;
      joystick.stickY = t.clientY;
    } else { 
      shootAt(t.clientX, t.clientY);
    }
  }
});
canvas.addEventListener("touchmove", e => {
  if(!joystick.active) return;
  for(let t of e.changedTouches){
    if(t.identifier === joystick.touchId){
      const dx = t.clientX - joystick.x, dy = t.clientY - joystick.y;
      const dist = Math.hypot(dx, dy), max = joystick.radius;
      if(dist>max){ joystick.stickX = joystick.x + dx/dist*max; joystick.stickY = joystick.y + dy/dist*max; }
      else { joystick.stickX = t.clientX; joystick.stickY = t.clientY; }
      joystick.vx = (joystick.stickX - joystick.x)/max*player.speed;
      joystick.vy = (joystick.stickY - joystick.y)/max*player.speed;
    }
  }
});
canvas.addEventListener("touchend", e => {
  for(let t of e.changedTouches){
    if(t.identifier === joystick.touchId){
      joystick.active = false;
      joystick.vx=0; joystick.vy=0;
      joystick.stickX = joystick.x; joystick.stickY = joystick.y;
      joystick.touchId = null;
    }
  }
});

function shootAt(tx, ty){
  const now = Date.now();
  if(reloading) return;
  if(ammo <= 0) {
    reloading = true;
    lastReload = now;
    return;
  }
  if(now - lastShot < 1000) return;
  const baseAngle = Math.atan2((ty - canvas.height/2), (tx - canvas.width/2));
  const spread = 0.2;
  const count = 5;
  for(let i=0;i<count;i++){
    const angle = baseAngle - spread/2 + (spread/(count-1))*i;
    bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle)*10, dy: Math.sin(angle)*10, size:10, trail:[] });
  }
  lastShot = now;
  ammo--;
}

function spawnEnemy(){
  const now = Date.now();
  if(now - lastSpawn > spawnInterval){
    let side = Math.floor(Math.random()*4);
    let ex, ey;
    switch(side){
      case 0: ex = player.x + Math.random()*canvas.width - canvas.width/2; ey = player.y - canvas.height/2 - 50; break;
      case 1: ex = player.x + canvas.width/2 + 50; ey = player.y + Math.random()*canvas.height - canvas.height/2; break;
      case 2: ex = player.x + Math.random()*canvas.width - canvas.width/2; ey = player.y + canvas.height/2 + 50; break;
      case 3: ex = player.x - canvas.width/2 - 50; ey = player.y + Math.random()*canvas.height - canvas.height/2; break;
    }
    enemies.push({
      x: ex, y: ey, radius:20, color:"red", speed:2 + Math.random()*1.5, hp:5, flash:0, vx:0, vy:0
    });
    lastSpawn = now;
  }
}

function resolveEnemyCollisions(){
  for(let i=0;i<enemies.length;i++){
    for(let j=i+1;j<enemies.length;j++){
      const e1 = enemies[i];
      const e2 = enemies[j];
      const dx = e2.x - e1.x;
      const dy = e2.y - e1.y;
      const dist = Math.hypot(dx, dy);
      const minDist = e1.radius + e2.radius;
      if(dist < minDist && dist>0){
        const overlap = minDist - dist;
        e1.x -= (dx/dist)*(overlap/2);
        e1.y -= (dy/dist)*(overlap/2);
        e2.x += (dx/dist)*(overlap/2);
        e2.y += (dy/dist)*(overlap/2);
      }
    }
  }
}

function checkLevelUp(){
  let xpNeeded = 10 + (player.level-1)*5;
  while(player.xp >= xpNeeded){
    player.xp -= xpNeeded;
    player.level++;
    xpNeeded = 10 + (player.level-1)*5;
  }
}

function update(){
  const nextX = player.x + joystick.vx;
  const nextY = player.y + joystick.vy;
  if(nextX - player.radius >= 0 && nextX + player.radius <= map.width) player.x = nextX;
  if(nextY - player.radius >= 0 && nextY + player.radius <= map.height) player.y = nextY;
  mapOffset.x = canvas.width/2 - player.x;
  mapOffset.y = canvas.height/2 - player.y;

  if(reloading && Date.now() - lastReload >= reloadTime){
    reloading = false;
    ammo = 2;
  }

  bullets.forEach(b=>{
    b.trail.push({x:b.x, y:b.y});
    if(b.trail.length>5) b.trail.shift();
    b.x += b.dx; b.y += b.dy;

    enemies.forEach(e=>{
      const dist = Math.hypot(b.x - e.x, b.y - e.y);
      if(dist < e.radius + b.size/2){
        e.hp -= 1;
        e.flash = 5;
        const angle = Math.atan2(e.y - player.y, e.x - player.x);
        const knockback = 15;
        e.vx = Math.cos(angle)*knockback;
        e.vy = Math.sin(angle)*knockback;
        b.hit = true;
      }
    });
  });
  bullets = bullets.filter(b=>b.x>0 && b.x<map.width && b.y>0 && b.y<map.height && !b.hit);

  enemies.forEach((e,i)=>{
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);
    
    e.x += e.vx + (dx/dist)*e.speed;
    e.y += e.vy + (dy/dist)*e.speed;
    const friction = 0.85;
    e.vx *= friction; e.vy *= friction;

    if(e.x - e.radius < 0) e.x = e.radius;
    if(e.x + e.radius > map.width) e.x = map.width - e.radius;
    if(e.y - e.radius < 0) e.y = e.radius;
    if(e.y + e.radius > map.height) e.y = map.height - e.radius;

    const minDist = e.radius + player.radius;
    if(dist < minDist && dist>0){
      const overlap = minDist - dist;
      e.x -= (dx/dist) * overlap;
      e.y -= (dy/dist) * overlap;
    }

    if(e.flash>0) e.flash--;

    if(e.hp <= 0){
      const count = 2 + Math.floor(Math.random()*2);
      for(let j=0;j<count;j++){
        xpList.push({ 
          x:e.x + (Math.random()*20-10),
          y:e.y + (Math.random()*20-10),
          radius:8,
          color:`yellow`,
          vx:0,
          vy:0
        });
      }
    }
  });

  resolveEnemyCollisions();
  enemies = enemies.filter(e=>e.hp>0);
  spawnEnemy();

  xpList.forEach((xp,i)=>{
    const dx = player.x - xp.x;
    const dy = player.y - xp.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 200){
      const pullSpeed = 0.5 + (200 - dist)/50; 
      xp.vx += (dx/dist)*pullSpeed;
      xp.vy += (dy/dist)*pullSpeed;
    }
    xp.x += xp.vx; xp.y += xp.vy;

    if(dist < player.radius){
      player.xp += 1;
      xpList.splice(i,1);
      checkLevelUp();
    }

    xp.vx *= 0.9; xp.vy *= 0.9;
  });
}

function draw(){
  ctx.fillStyle="#228B22";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  grass.forEach(g=>{
    ctx.fillStyle=g.color;
    ctx.beginPath();
    ctx.arc(g.x+mapOffset.x, g.y+mapOffset.y, g.size/2,0,Math.PI*2);
    ctx.fill();
  });

  ctx.strokeStyle="white"; ctx.lineWidth=4;
  ctx.strokeRect(mapOffset.x, mapOffset.y, map.width, map.height);

  ctx.fillStyle=player.color;
  ctx.beginPath();
  ctx.arc(player.x+mapOffset.x, player.y+mapOffset.y, player.radius,0,Math.PI*2);
  ctx.fill();

  bullets.forEach(b=>{
    const trailLen = b.trail.length;
    b.trail.forEach((t,i)=>{
      const ratio = (i+1)/trailLen; 
      const scale = 0.2 + 0.6*ratio; 
      const alpha = 0.2 + 0.5*ratio;
      ctx.fillStyle = `rgba(255,165,0,${alpha})`;
      ctx.beginPath();
      ctx.arc(t.x+mapOffset.x, t.y+mapOffset.y, (b.size/2)*scale,0,Math.PI*2);
      ctx.fill();
    });
    ctx.fillStyle="orange";
    ctx.beginPath();
    ctx.arc(b.x+mapOffset.x, b.y+mapOffset.y, b.size/2,0,Math.PI*2);
    ctx.fill();
  });

  enemies.forEach(e=>{
    ctx.fillStyle = e.flash>0 ? "yellow" : e.color;
    ctx.beginPath();
    ctx.arc(e.x+mapOffset.x, e.y+mapOffset.y, e.radius,0,Math.PI*2);
    ctx.fill();
  });

  xpList.forEach(xp=>{
    ctx.fillStyle = xp.color;
    ctx.beginPath();
    ctx.arc(xp.x+mapOffset.x, xp.y+mapOffset.y, xp.radius,0,Math.PI*2);
    ctx.fill();
  });

  ctx.strokeStyle="#888"; ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(joystick.x, joystick.y, joystick.radius,0,Math.PI*2);
  ctx.stroke();
  ctx.fillStyle="#555";
  ctx.beginPath();
  ctx.arc(joystick.stickX, joystick.stickY,25,0,Math.PI*2);
  ctx.fill();

  const barWidth = 150, barHeight = 15, padding = 10;
  const xPos = canvas.width - barWidth - padding;
  const yHp = canvas.height - padding - barHeight*2 - 5;
  const yXp = canvas.height - padding - barHeight;

  ctx.fillStyle="gray";
  ctx.fillRect(xPos, yHp, barWidth, barHeight);
  ctx.fillStyle="red";
  ctx.fillRect(xPos, yHp, barWidth * (player.hp/player.maxHp), barHeight);

  const xpNeeded = 10 + (player.level-1)*5;
  ctx.fillStyle="gray";
  ctx.fillRect(xPos, yXp, barWidth, barHeight);
  ctx.fillStyle="yellow";
  ctx.fillRect(xPos, yXp, barWidth * (player.xp/xpNeeded), barHeight);

  ctx.fillStyle="white";
  ctx.font="16px Arial";
  ctx.textAlign="right";
  ctx.fillText(`Lv ${player.level}`, xPos - 10, yXp + barHeight -2);
  ctx.fillText(`${xpNeeded - player.xp} left`, xPos - 10, yXp + barHeight +14);

  ctx.font="20px Arial";
  ctx.textAlign="left";
  ctx.fillStyle="white";
  ctx.fillText(`Shotgun ${ammo}`, xPos, yHp - 20);
  if(reloading){
    ctx.fillStyle="red";
    ctx.fillText("RELOADING", xPos, yHp - 40);
  }

  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.textAlign = "center";
  ctx.fillText(VERSION, canvas.width/2, 30);
  ctx.textAlign = "start";
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
