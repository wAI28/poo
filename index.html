<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>탕탕특공대 샷건 v.9</title>
<style>
  body { margin:0; overflow:hidden; background:#222; }
  canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const VERSION = "v.9";

// 맵
const map = { width: canvas.width*5, height: canvas.height*5 };

// 플레이어
const player = { x: map.width/2, y: map.height/2, radius:20, color:"white", speed:5, xp:0 };

// 샷건
let bullets = [];
let lastShot = 0;

// 조이스틱
const joystick = { 
  radius: 80,
  x: 150, 
  y: canvas.height - 150,
  stickX: 150, stickY: canvas.height - 150,
  active:false, vx:0, vy:0,
  touchId:null
};

// 풀 1200개
const grass = [];
for(let i=0;i<1200;i++){
  grass.push({ x: Math.random()*map.width, y: Math.random()*map.height, size:3 + Math.random()*4, color: Math.random()>0.5 ? "#7cfc00" : "#adff2f" });
}

let mapOffset = {x: canvas.width/2 - player.x, y: canvas.height/2 - player.y};

// 적
let enemies = [];
const spawnInterval = 2000; 
let lastSpawn = 0;

// 경험치
let xpList = [];

// 터치 이벤트
canvas.addEventListener("touchstart", e => {
  for(let t of e.changedTouches){
    const dx = t.clientX - joystick.x;
    const dy = t.clientY - joystick.y;
    if(Math.hypot(dx, dy)<=joystick.radius && joystick.touchId===null){ 
      joystick.active = true;
      joystick.touchId = t.identifier;
      joystick.stickX = t.clientX;
      joystick.stickY = t.clientY;
    } else { 
      shootAt(t.clientX, t.clientY);
    }
  }
});
canvas.addEventListener("touchmove", e => {
  if(!joystick.active) return;
  for(let t of e.changedTouches){
    if(t.identifier === joystick.touchId){
      const dx = t.clientX - joystick.x, dy = t.clientY - joystick.y;
      const dist = Math.hypot(dx, dy), max = joystick.radius;
      if(dist>max){ joystick.stickX = joystick.x + dx/dist*max; joystick.stickY = joystick.y + dy/dist*max; }
      else { joystick.stickX = t.clientX; joystick.stickY = t.clientY; }
      joystick.vx = (joystick.stickX - joystick.x)/max*player.speed;
      joystick.vy = (joystick.stickY - joystick.y)/max*player.speed;
    }
  }
});
canvas.addEventListener("touchend", e => {
  for(let t of e.changedTouches){
    if(t.identifier === joystick.touchId){
      joystick.active = false;
      joystick.vx=0; joystick.vy=0;
      joystick.stickX = joystick.x; joystick.stickY = joystick.y;
      joystick.touchId = null;
    }
  }
});

// 샷건 발사
function shootAt(tx, ty){
  const now = Date.now();
  if(now - lastShot < 1000) return;
  const baseAngle = Math.atan2((ty - canvas.height/2), (tx - canvas.width/2));
  const spread = 0.2;
  const count = 5;
  for(let i=0;i<count;i++){
    const angle = baseAngle - spread/2 + (spread/(count-1))*i;
    bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle)*10, dy: Math.sin(angle)*10, size:10, trail:[] });
  }
  lastShot = now;
}

// 적 스폰
function spawnEnemy(){
  const now = Date.now();
  if(now - lastSpawn > spawnInterval){
    enemies.push({
      x: Math.random()*map.width,
      y: Math.random()*map.height,
      radius:20,
      color:"red",
      speed:2 + Math.random()*1.5,
      hp:5,
      flash:0,
      vx:0, vy:0 // 넉백 관성
    });
    lastSpawn = now;
  }
}

// 적 충돌
function resolveEnemyCollisions(){
  for(let i=0;i<enemies.length;i++){
    for(let j=i+1;j<enemies.length;j++){
      const e1 = enemies[i];
      const e2 = enemies[j];
      const dx = e2.x - e1.x;
      const dy = e2.y - e1.y;
      const dist = Math.hypot(dx, dy);
      const minDist = e1.radius + e2.radius;
      if(dist < minDist && dist>0){
        const overlap = minDist - dist;
        e1.x -= (dx/dist)*(overlap/2);
        e1.y -= (dy/dist)*(overlap/2);
        e2.x += (dx/dist)*(overlap/2);
        e2.y += (dy/dist)*(overlap/2);
      }
    }
  }
}

// 업데이트
function update(){
  // 플레이어 이동
  const nextX = player.x + joystick.vx;
  const nextY = player.y + joystick.vy;
  if(nextX - player.radius >= 0 && nextX + player.radius <= map.width) player.x = nextX;
  if(nextY - player.radius >= 0 && nextY + player.radius <= map.height) player.y = nextY;
  mapOffset.x = canvas.width/2 - player.x;
  mapOffset.y = canvas.height/2 - player.y;

  // 총알 이동 + 잔상 + 적 피격
  bullets.forEach(b=>{
    b.trail.push({x:b.x, y:b.y});
    if(b.trail.length>5) b.trail.shift();
    b.x += b.dx; b.y += b.dy;

    enemies.forEach(e=>{
      const dist = Math.hypot(b.x - e.x, b.y - e.y);
      if(dist < e.radius + b.size/2){
        e.hp -= 1;
        e.flash = 5;
        const angle = Math.atan2(e.y - player.y, e.x - player.x);
        const knockback = 15;
        e.vx = Math.cos(angle)*knockback;
        e.vy = Math.sin(angle)*knockback;
        b.hit = true;
      }
    });
  });
  bullets = bullets.filter(b=>b.x>0 && b.x<map.width && b.y>0 && b.y<map.height && !b.hit);

  // 적 이동 + 넉백 관성 + 플레이어 충돌
  enemies.forEach((e,i)=>{
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);
    
    e.x += e.vx + (dx/dist)*e.speed;
    e.y += e.vy + (dy/dist)*e.speed;

    const friction = 0.85;
    e.vx *= friction;
    e.vy *= friction;

    // 맵 경계
    if(e.x - e.radius < 0) e.x = e.radius;
    if(e.x + e.radius > map.width) e.x = map.width - e.radius;
    if(e.y - e.radius < 0) e.y = e.radius;
    if(e.y + e.radius > map.height) e.y = map.height - e.radius;

    // 플레이어와 충돌 처리
    const minDist = e.radius + player.radius;
    if(dist < minDist && dist>0){
      const overlap = minDist - dist;
      e.x -= (dx/dist) * overlap;
      e.y -= (dy/dist) * overlap;
    }

    if(e.flash>0) e.flash--;

    // 적 사망 → 경험치 생성
    if(e.hp <= 0){
      const count = 2 + Math.floor(Math.random()*2);
      for(let j=0;j<count;j++){
        xpList.push({ 
          x:e.x + (Math.random()*20-10),
          y:e.y + (Math.random()*20-10),
          radius:8,
          color:"blue",
          vx:0,
          vy:0
        });
      }
    }
  });

  resolveEnemyCollisions();
  enemies = enemies.filter(e=>e.hp>0);
  spawnEnemy();

  // 경험치 업데이트
  xpList.forEach((xp,i)=>{
    const dx = player.x - xp.x;
    const dy = player.y - xp.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 200){ // 플레이어 가까이 오면 끌림
      const pullSpeed = 0.5 + (200 - dist)/50; 
      xp.vx += (dx/dist)*pullSpeed;
      xp.vy += (dy/dist)*pullSpeed;
    }
    xp.x += xp.vx;
    xp.y += xp.vy;

    // 플레이어 흡수
    if(dist < player.radius){
      player.xp += 1;
      xpList.splice(i,1);
    }

    // 감속
    xp.vx *= 0.9;
    xp.vy *= 0.9;
  });
}

// 그리기
function draw(){
  ctx.fillStyle="#228B22";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  grass.forEach(g=>{
    ctx.fillStyle=g.color;
    ctx.beginPath();
    ctx.arc(g.x+mapOffset.x, g.y+mapOffset.y, g.size/2,0,Math.PI*2);
    ctx.fill();
  });

  ctx.strokeStyle="white"; ctx.lineWidth=4;
  ctx.strokeRect(mapOffset.x, mapOffset.y, map.width, map.height);

  ctx.fillStyle=player.color;
  ctx.beginPath();
  ctx.arc(player.x+mapOffset.x, player.y+mapOffset.y, player.radius,0,Math.PI*2);
  ctx.fill();

  bullets.forEach(b=>{
    const trailLen = b.trail.length;
    b.trail.forEach((t,i)=>{
      const ratio = (i+1)/trailLen; 
      const scale = 0.2 + 0.6*ratio; 
      const alpha = 0.2 + 0.5*ratio;
      ctx.fillStyle = `rgba(255,165,0,${alpha})`;
      ctx.beginPath();
      ctx.arc(t.x+mapOffset.x, t.y+mapOffset.y, (b.size/2)*scale,0,Math.PI*2);
      ctx.fill();
    });
    ctx.fillStyle="orange";
    ctx.beginPath();
    ctx.arc(b.x+mapOffset.x, b.y+mapOffset.y, b.size/2,0,Math.PI*2);
    ctx.fill();
  });

  enemies.forEach(e=>{
    ctx.fillStyle = e.flash>0 ? "yellow" : e.color;
    ctx.beginPath();
    ctx.arc(e.x+mapOffset.x, e.y+mapOffset.y, e.radius,0,Math.PI*2);
    ctx.fill();
  });

  // 경험치
  xpList.forEach(xp=>{
    ctx.fillStyle = xp.color;
    ctx.beginPath();
    ctx.arc(xp.x+mapOffset.x, xp.y+mapOffset.y, xp.radius,0,Math.PI*2);
    ctx.fill();
  });

  // 조이스틱
  ctx.strokeStyle="#888"; ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(joystick.x, joystick.y, joystick.radius,0,Math.PI*2);
  ctx.stroke();
  ctx.fillStyle="#555";
  ctx.beginPath();
  ctx.arc(joystick.stickX, joystick.stickY,25,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.textAlign = "center";
  ctx.fillText(VERSION, canvas.width/2, 30);
  ctx.textAlign = "start";
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
